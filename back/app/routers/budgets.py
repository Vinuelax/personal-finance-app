from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel, ConfigDict, Field
from datetime import datetime, timezone

from utils.deps import get_db, get_current_user
from utils.db import DB, list_budgets

router = APIRouter(tags=["budgets"])


class BudgetIn(BaseModel):
    model_config = ConfigDict(json_schema_extra={
        "example": {
            "month": "2026-02",
            "categoryId": "cat_groceries",
            "limit": 250000,
            "rollover": False,
            "rolloverTargetCategoryId": "cat_savings",
            "currency": "USD",
            "purpose": "Ski trip installment",
            "carryForwardEnabled": True,
            "isTerminal": False,
            "objectiveId": None,
        }
    })

    month: str = Field(..., description="Month in YYYY-MM format")
    categoryId: str = Field(..., description="Category this budget applies to")
    limit: int = Field(..., description="Spending limit in minor units")
    rollover: bool = Field(False, description="Whether leftover budget rolls over")
    rolloverTargetCategoryId: str | None = Field(None, description="Category to receive surplus if rollover is enabled")
    currency: str | None = Field(None, description="Currency code, defaults to user's currency")
    purpose: str | None = Field(None, description="Optional purpose/label for this budget")
    carryForwardEnabled: bool = Field(True, description="Whether this budget can be used as fallback for future months")
    isTerminal: bool = Field(False, description="Whether this budget is the last month for this entry")
    objectiveId: str | None = Field(None, description="Owning objective id, if generated by objectives")


class BudgetUpdate(BaseModel):
    model_config = ConfigDict(json_schema_extra={
        "example": {
            "limit": 275000,
            "rollover": True,
            "rolloverTargetCategoryId": "cat_savings",
            "currency": "USD",
            "purpose": "Ski trip installment",
            "carryForwardEnabled": False,
            "isTerminal": True,
            "objectiveId": "obj_trip",
        }
    })

    limit: Optional[int] = Field(None, description="Updated spending limit")
    rollover: Optional[bool] = Field(None, description="Updated rollover flag")
    rolloverTargetCategoryId: str | None = Field(None, description="Category to receive surplus if rollover is enabled")
    currency: str | None = Field(None, description="Currency code override")
    purpose: str | None = Field(None, description="Optional purpose/label for this budget")
    carryForwardEnabled: Optional[bool] = Field(None, description="Whether this budget can be used as fallback for future months")
    isTerminal: Optional[bool] = Field(None, description="Whether this budget is a terminal month")
    objectiveId: str | None = Field(None, description="Owning objective id, if generated by objectives")


class Budget(BudgetIn):
    pass


def _now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()


@router.get(
    "",
    response_model=List[Budget],
    summary="List budgets",
    description="List monthly budgets for the authenticated user, optionally filtered by month."
)
def api_list_budgets(month: Optional[str] = None, current_user=Depends(get_current_user), db: DB = Depends(get_db)):
    items = list_budgets(db, current_user["user_id"], month)
    if month:
        # Resolve month view from latest budget <= requested month per category.
        all_items = list_budgets(db, current_user["user_id"], None)
        latest: dict[str, dict] = {}
        for i in all_items:
            m = i.get("month")
            cid = i.get("categoryId")
            if not m or not cid:
                continue
            if m > month:
                continue
            current = latest.get(cid)
            if not current or m > current.get("month", ""):
                latest[cid] = i
        filtered = []
        for i in latest.values():
            budget_month = i.get("month")
            if budget_month == month:
                filtered.append(i)
                continue
            if not i.get("carryForwardEnabled", True):
                continue
            if i.get("isTerminal", False):
                continue
            filtered.append(i)
        items = filtered

    return [
        {
            "month": i.get("month"),
            "categoryId": i.get("categoryId"),
            "limit": i.get("limit"),
            "rollover": i.get("rollover", False),
            "rolloverTargetCategoryId": i.get("rolloverTargetCategoryId"),
            "currency": i.get("currency"),
            "copiedFromMonth": i.get("copiedFromMonth"),
            "purpose": i.get("purpose"),
            "carryForwardEnabled": i.get("carryForwardEnabled", True),
            "isTerminal": i.get("isTerminal", False),
            "objectiveId": i.get("objectiveId"),
        }
        for i in items
    ]


@router.post(
    "",
    response_model=Budget,
    summary="Create budget",
    description="Create a budget for a given month and category."
)
def api_create_budget(payload: BudgetIn, current_user=Depends(get_current_user), db: DB = Depends(get_db)):
    existing = db.get_budget(current_user["user_id"], payload.month, payload.categoryId)
    if existing:
        raise HTTPException(status_code=409, detail="Budget already exists for this month/category")
    created = db.create_budget(current_user["user_id"], payload.model_dump())
    return created


@router.patch(
    "/{month}/{category_id}",
    response_model=Budget,
    summary="Update budget",
    description="Update budget limit or rollover flag."
)
def api_update_budget(month: str, category_id: str, payload: BudgetUpdate, current_user=Depends(get_current_user), db: DB = Depends(get_db)):
    updates = {k: v for k, v in payload.model_dump(exclude_none=True).items()}
    updated = db.update_budget(current_user["user_id"], month, category_id, updates)
    if not updated:
        raise HTTPException(404, "Budget not found")
    return updated


@router.put(
    "/{month}/{category_id}",
    response_model=Budget,
    summary="Upsert budget",
    description="Create or update a budget for a given month/category."
)
def api_upsert_budget(
    month: str,
    category_id: str,
    payload: BudgetIn,
    apply_future: bool = Query(False, alias="applyFuture", description="When true, update current and all future budget entries for this category"),
    current_user=Depends(get_current_user),
    db: DB = Depends(get_db),
):
    if payload.month != month or payload.categoryId != category_id:
        raise HTTPException(400, "Payload month/category mismatch")
    existing = db.get_budget(current_user["user_id"], month, category_id)
    if apply_future:
        return db.upsert_budget_with_future(current_user["user_id"], month, category_id, payload.model_dump())
    if existing:
        return db.update_budget(current_user["user_id"], month, category_id, payload.model_dump())
    return db.create_budget(current_user["user_id"], payload.model_dump())


@router.delete(
    "/{month}/{category_id}",
    summary="Delete budget",
    description="Delete a budget entry."
)
def api_delete_budget(month: str, category_id: str, current_user=Depends(get_current_user), db: DB = Depends(get_db)):
    ok = db.delete_budget(current_user["user_id"], month, category_id)
    if not ok:
        raise HTTPException(404, "Budget not found")
    return {"deleted": True}


@router.delete(
    "/scope",
    summary="Delete budgets by scope",
    description="Delete this month, from this month onwards, or all budget entries for a category."
)
def api_delete_budgets_scoped(
    category_id: str = Query(..., alias="categoryId", description="Category id"),
    scope: str = Query(..., pattern="^(this_month|from_month|all)$"),
    month: Optional[str] = Query(None, description="Required for this_month/from_month scopes"),
    current_user=Depends(get_current_user),
    db: DB = Depends(get_db),
):
    if scope in {"this_month", "from_month"} and not month:
        raise HTTPException(400, "month is required for this scope")
    deleted = db.delete_budgets_scoped(current_user["user_id"], category_id, month, scope)
    return {"deleted": deleted > 0, "count": deleted}


@router.post(
    "/{month}/copy-from/{source_month}",
    response_model=List[Budget],
    summary="Copy budgets from another month",
    description="Clone all budgets from source_month into month if they don't already exist."
)
def api_copy_budgets(month: str, source_month: str, current_user=Depends(get_current_user), db: DB = Depends(get_db)):
    created = db.copy_budgets(current_user["user_id"], month, source_month)
    return created
